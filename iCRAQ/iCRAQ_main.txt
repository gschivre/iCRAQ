//iCRAQ stand for imageJ Chromocenter Recognition And Quantification
run("Action Bar","/macros/iCRAQ/iCRAQ_main.txt");
exit();

<startupAction>
requires("1.52r")
setBackgroundColor(0, 0, 0);
run("Set Measurements...", "redirect=None");
run("FeatureJ Options", "progress");
call("ij.Prefs.set", "variable.macro.nucleus.nNuc", 0);
if(nImages()>0) {
	run("Select None");
	run("Remove Overlay");
}
roiManager("reset");
setBatchMode(true);
//Get IDs of all opened images
ImgNamearr=newArray(nImages);
for(i=0; i<nImages; ++i){
	selectImage(i+1);
	temp=getImageID();
	ImgNamearr[i]=temp;
}
call("ij.Prefs.set", "variable.macro.nucleus.openImg", String.join(ImgNamearr,","));
call("ij.Prefs.set", "variable.macro.nucleus.scale", 1);
call("ij.Prefs.set", "variable.macro.nucleus.rad", 15);
call("ij.Prefs.set", "variable.macro.nucleus.proj", "Standard Deviation");
call("ij.Prefs.set", "variable.macro.nucleus.threshnuc", "Li");
call("ij.Prefs.set", "variable.macro.nucleus.MinNuc", 1.25);
call("ij.Prefs.set", "variable.macro.nucleus.sfanuc", false);
call("ij.Prefs.set", "variable.macro.nucleus.enlarge", 0);
call("ij.Prefs.set", "variable.macro.nucleus.exclude", false);
call("ij.Prefs.set", "variable.macro.nucleus.radchr", 3);
call("ij.Prefs.set", "variable.macro.nucleus.FJsmooth", 0.5);
call("ij.Prefs.set", "variable.macro.nucleus.FJint", 3.0);
call("ij.Prefs.set", "variable.macro.nucleus.MinChr", 0.15);
call("ij.Prefs.set", "variable.macro.nucleus.MaxChr", 0.5);
call("ij.Prefs.set", "variable.macro.nucleus.bitdepth", "8-bit");
call("ij.Prefs.set", "variable.macro.nucleus.lifs", "");
call("ij.Prefs.set", "variable.macro.nucleus.sCount", 0);
call("ij.Prefs.set", "variable.macro.nucleus.serie", 0);
setBatchMode(false);
print("Drag and Drop one or more files (.lif or .tif) on the macro menu to start !");
</startupAction>

<codeLibrary>
//Append new value to existing array
function appendarr(arr, value) {
	arr2 = newArray(arr.length+1);
	for (i=0; i<arr.length; i++){
		arr2[i] = arr[i];
	}
	arr2[arr.length] = value;
	return arr2;
}
//Give ROI index of the ROI named [roiName]
function findRoiWithName(roiName) { 
	nR = roiManager("Count"); 
	for (i=0; i<nR; i++) { 
		roiManager("Select", i); 
		rName = Roi.getName(); 
		if (matches(rName, roiName)) { 
			return i; 
		} 
	} 
	return -1; 
}
//Return the index in n digit format
function nDigitsIndex(val,n){
	arr=newArray(n);
	val=toString(val);
	trail=n-val.length;
	for(i=0; i<trail; ++i){
		arr[i]="0";
	}
	stridx=0;
	for(i=trail; i<n; ++i){
		arr[i]=substring(val, stridx, stridx+1);
		stridx=stridx+1;
	}
	return String.join(arr, "")
}
//Close image but specified one
function closeBut(id,type){
	setBatchMode(true);
	remainImages=nImages;
	while(remainImages>id.length){
		imID=newArray(nImages);
		for(i=0; i<nImages; ++i){
			selectImage(i+1);
			if(type=="id"){
				imID[i]=getImageID();
			}
			else if(type=="title"){
				imID[i]=getTitle();		
			}
		}
		for(i=0; i<nImages; ++i){
			arr=newArray(id.length);
			for(j=0; j<id.length; ++j){
				if(type=="id"){
					test=imID[i]==id[j];
				}
				else{
					test=matches(imID[i],id[j]);
				}
				if(!test){
					arr[j]=1;
				}
				else{
					arr[j]=0;
				}
			}
			if(sum(arr)==arr.length){
				selectImage(imID[i]);  		
         		close();
     		}
		}
		remainImages=nImages;
	}
	setBatchMode(false);
}
//Close non image windows
function closeWindow(){
	setBatchMode(true);
	windowlist=getList("window.titles");
	for(i=0; i<windowlist.length; ++i){
		if(!matches(windowlist[i],".*ROI.*")){
			close(windowlist[i]);
		}
	}
	setBatchMode(false);
}
//Count files in folder
function countFiles(dir) {
	list = getFileList(dir);
	count=0;
	for (i=0; i<list.length; i++) {
		if (endsWith(list[i], "/")){
			count=count+countFiles(""+dir+list[i]);
		}
		else{
			count++;
		}
	}
	return count;
}
//Sum of an array
function sum(arr){
	s=0;
	for(i=0; i<arr.length; ++i){
		s=s+arr[i];	
	}
	return s;
}
//create a sequence array starting from start to end
function start_end_getSequence(start, end) {
	arr = Array.getSequence(end-start+1);
	for (i=0; i<arr.length; i++){
		arr[i] = arr[i]+start;
	}
	return arr;
}
//Convert radius in µm to the area of the corresponding circle in pixel^2 using the voxel size of the current stack and the scale factor to convert stack unit to µm
function getProjectedArea(rad, scalefactor){
	getVoxelSize(width, height, depth, unit);
	return PI*rad*rad/scalefactor/scalefactor/width/height
}
</codeLibrary>

<DnDAction>
file=getArgument();
//Update .lif files list
var lifs=call("ij.Prefs.get", "variable.macro.nucleus.lifs", "");
lifs=split(lifs, ",");
if(lifs.length>0){
	cpt=0;
	for(i=0; i<lifs.length; i++){
		if(file!=lifs[i]){
			cpt++;
		}
	}
	if(cpt>=lifs.length){
		newLifs=newArray(lifs.length+1);
		for (i=0; i<lifs.length; i++){
			newLifs[i]=lifs[i];
		}
		newLifs[lifs.length]=file;
		call("ij.Prefs.set", "variable.macro.nucleus.lifs", String.join(newLifs,","));
	}
}
else{
	newLifs=newArray(1);
	newLifs[0]=file;
	call("ij.Prefs.set", "variable.macro.nucleus.lifs", String.join(newLifs,","));
	run("Bio-Formats Macro Extensions");
	Ext.setId(file);
	Ext.getSeriesCount(seriesCount);
	sCount=seriesCount;
	call("ij.Prefs.set", "variable.macro.nucleus.sCount", sCount);
	run("Bio-Formats Importer", "open=["+file+"] autoscale color_mode=Default split_channels view=Hyperstack stack_order=XYCZT series_"+(1));
	call("ij.Prefs.set", "variable.macro.nucleus.serie", 1);
}
//Get IDs of all opened images
ImgNamearr=newArray(nImages);
for(i=0; i<nImages; ++i){
	selectImage(i+1);
	temp=getImageID();
	ImgNamearr[i]=temp;
}
call("ij.Prefs.set", "variable.macro.nucleus.openImg", String.join(ImgNamearr,","));
</DnDAction>

<line>
<button>
label=Option
icon=noicon
arg=<macro>
var methods=getList("threshold.methods");
Dialog.create("Options");
Dialog.addMessage("Choose settings for nucleus/chromocenters segmentation");
//Scale factor for converting image unit to µm
Dialog.addNumber("Image scale factor:", 1);
//sufficiently large to smooth out chromocenters
Dialog.addNumber("Median filter size (pixels):", 15);
//Std is ok !
Dialog.addChoice("Projection Type:", newArray("Standard Deviation", "Max Intensity"));
//Default Li
Dialog.addChoice("Nucleus Threshold Method:", methods, "Li");
//Circle with radius of about 2.5µm
Dialog.addNumber("Nucleus minimum radius ("+getInfo("micrometer.abbreviation")+"):", 1.25);
//To display the adjust threshold window
Dialog.addCheckbox("Show", false);
//How many pixel to take outside of nucleus to crop
Dialog.addNumber("Enlarge nucleus for croping by (pixels):", 0);
//Keep nuclei on image border or not
Dialog.addCheckbox("Exclude nuclei on border", false);
//Median smoothing not very usefull
Dialog.addNumber("Median filter size for chromocenter (pixels):", 3);
//Parameters for FeatureJ
Dialog.addNumber("FeatureJ smoothing:", 0.5);
Dialog.addNumber("FeatureJ integration:", 3.0);
//Circle with radius of about 0.05µm --> 50nm
Dialog.addNumber("Chromocenter minimum radius ("+getInfo("micrometer.abbreviation")+"):", 0.15);
//This will avoid to detect nucleus as chromocenter when there is no chromocenter
Dialog.addNumber("Chromocenter maximum size (% of nucleus):", 0.5);
//Best working on 8-bit for speed
Dialog.addChoice("Threshold On:", newArray("8-bit", "16-bit"));
Dialog.show();
sf=Dialog.getNumber();
rad=Dialog.getNumber();
proj=Dialog.getChoice();
threshnuc=Dialog.getChoice();
MinNuc=Dialog.getNumber();
sfanuc=Dialog.getCheckbox();
enlarge=Dialog.getNumber();
exclude=Dialog.getCheckbox();
radchr=Dialog.getNumber();
FJsmooth=Dialog.getNumber();
FJint=Dialog.getNumber();
MinChr=Dialog.getNumber();
MaxChr=Dialog.getNumber();
bitdepth=Dialog.getChoice();
call("ij.Prefs.set", "variable.macro.nucleus.scale", sf);
call("ij.Prefs.set", "variable.macro.nucleus.rad", rad);
call("ij.Prefs.set", "variable.macro.nucleus.proj", proj);
call("ij.Prefs.set", "variable.macro.nucleus.threshnuc", threshnuc);
call("ij.Prefs.set", "variable.macro.nucleus.MinNuc", MinNuc);
call("ij.Prefs.set", "variable.macro.nucleus.sfanuc", sfanuc);
call("ij.Prefs.set", "variable.macro.nucleus.enlarge", enlarge);
call("ij.Prefs.set", "variable.macro.nucleus.exclude", exclude);
call("ij.Prefs.set", "variable.macro.nucleus.radchr", radchr);
call("ij.Prefs.set", "variable.macro.nucleus.FJsmooth", FJsmooth);
call("ij.Prefs.set", "variable.macro.nucleus.FJint", FJint);
call("ij.Prefs.set", "variable.macro.nucleus.MinChr", MinChr);
call("ij.Prefs.set", "variable.macro.nucleus.MaxChr", MaxChr);
call("ij.Prefs.set", "variable.macro.nucleus.bitdepth", bitdepth);
</macro>
</line>

<line>
<button>
label=Detect Nucleus
icon=noicon
arg=<macro>
//this will first z-project the stack then do watershed segmentation to get all nucleus bouding boxes
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var exclude=call("ij.Prefs.get","variable.macro.nucleus.exclude",false);
var sf=call("ij.Prefs.get","variable.macro.nucleus.sf",1);
var rad=call("ij.Prefs.get","variable.macro.nucleus.rad",15);
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var threshnuc=call("ij.Prefs.get","variable.macro.nucleus.threshnuc","Li");
threshnuc=threshnuc+" dark";
var MinNuc=call("ij.Prefs.get","variable.macro.nucleus.MinNuc",1.25);
//convert MinNuc to area in pixel^2
MinNuc = getProjectedArea(MinNuc, sf);
var sfanuc=!call("ij.Prefs.get","variable.macro.nucleus.sfanuc",true);
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
var bitdepth=call("ij.Prefs.get","variable.macro.nucleus.bitdepth","8-bit");
id=getImageID();
s=nSlices();
run("Grays");
if(sfanuc){
	setBatchMode(true);
	if(s > 1){
		run("Z Project...", "projection=["+proj+"]");
	}
	else{
		run("Select None");
		run("Duplicate...", " ");
	}
	run("Median...", "radius=&rad");
	run(bitdepth);
	setAutoThreshold(threshnuc);
	getThreshold(lower, upper);
	setThreshold(lower, upper);
	run("Create Mask");
}
else{
	if(s > 1){
		run("Z Project...", "projection=["+proj+"]");
	}
	else{
		run("Select None");
		run("Duplicate...", " ");
	}
	setBatchMode(true);
	run("Median...", "radius=&rad");
	run(bitdepth);
	setAutoThreshold(threshnuc);
	run("Threshold...");
	waitForUser("Adjust threshold, apply then click OK.");
	close("Threshold");
}
run("Fill Holes");
run("Watershed");
//best to remove borders nucelus --> don't for deeplearning
if(exclude){
	run("Analyze Particles...", "size=&MinNuc-Infinity pixel exclude add");
}
else{
	run("Analyze Particles...", "size=&MinNuc-Infinity pixel add");
}
selectImage(id);
closeBut(openImg,"id");
newNuc=roiManager("count")-nNuc;
for(i=nNuc; i<roiManager("count"); ++i){
	roiManager("Select", i);
	idx=i+1;
	idx=nDigitsIndex(idx,3);
	roiManager("rename","Nuc_"+idx);
}
call("ij.Prefs.set", "variable.macro.nucleus.nNuc", nNuc+newNuc);
roiManager("Show All with labels");
roiManager("Deselect");
setBatchMode(false);
</macro>
</line>

<line>
<button>
label=Manualy Add Nucleus
icon=noicon
arg=<macro>
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
var sf=call("ij.Prefs.get","variable.macro.nucleus.sf",1);
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var MinNuc=call("ij.Prefs.get","variable.macro.nucleus.MinNuc",1.25);
//convert MinNuc to area in pixel^2
MinNuc = getProjectedArea(MinNuc, sf);
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
id=getImageID();
s=nSlices();
if(s > 1){
	run("Z Project...", "projection=["+proj+"]");
}
else{
	run("Select None");
	run("Duplicate...", " ");
}
run("Grays");
run("Invert LUT");
roiManager("Show All Without Labels");
waitForUser("Use freehand selection to define nucleus outline, then click OK.");
roiManager("add");
roiManager("select", roiManager("count")-1);
nucArea=getValue("Area raw");
if(nucArea<MinNuc){
	roiManager("Delete");
}
else{
	nNuc=nNuc+1;
	call("ij.Prefs.set", "variable.macro.nucleus.nNuc", nNuc);
	idx=nDigitsIndex(nNuc,3);
	roiManager("rename","Nuc_"+idx);
}
selectImage(id);
roiManager("Show All with labels");
closeBut(openImg,"id");
</macro>
</line>

<line>
<button>
label=Remove Nucleus
icon=noicon
arg=<macro>
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
if(nNuc==0){
	print("No Nucleus detected");
}
else{
	id=getImageID();
	s=nSlices();
	if(s > 1){
		run("Z Project...", "projection=["+proj+"]");
	}
	else{
		run("Select None");
		run("Duplicate...", " ");
	}
	roiManager("Show All with labels");
	waitForUser("Select the ROI of the unwanted nucleus, then click OK.");
	dName=Roi.getName();
	//If ROI is not a nucleus
	if(!matches(dName,"Nuc.*")){
		print("Choose a nucleus ROI");
	}
	else{
		indexnuc=-1;
		index=roiManager("index")+1;
		for(i=0; i<index; i++){
			roiManager("Select",i);
			rName=Roi.getName();
			if(!matches(rName,".*Chr.*")){
				indexnuc++;
			}
		}
		//Delete nucleus and associated chromocenter if exist
		todel=newArray(0);
		todel=appendarr(todel, dName);
		for(i=0; i<roiManager("count"); ++i){
			roiManager("Select",i);
			rName=Roi.getName();
			if(matches(rName,dName+"_Chr.*")){
				todel=appendarr(todel, rName);
			}
		}
		for(i=0; i<todel.length; ++i){
			delidx=findRoiWithName(todel[i]);
			roiManager("Select",delidx);
			roiManager("Delete");
		}
		nNuc=nNuc-1;
		selectImage(id);
		setBatchMode(true);
		//Rename Nucleus
		cpt=0;
		for(i=0; i<roiManager("count"); ++i){
			roiManager("Select", i);
			rName=Roi.getName();
			if(!matches(rName,".*Chr.*")){
				cpt=cpt+1;
				idx=nDigitsIndex(cpt,3);
				roiManager("rename","Nuc_"+idx);
			}
			else{
				rName=Roi.getName();
				rNamearr=split(rName,"_");
				roiManager("rename","Nuc_"+idx+"_"+rNamearr[2]+"_"+rNamearr[3]);
			}
		}
		roiManager("sort");
		roiManager("Show All with labels");
		closeBut(openImg,"id");
		call("ij.Prefs.set", "variable.macro.nucleus.nNuc", nNuc);
	}
	setBatchMode(false);
}
</macro>
</line>

<line>
<button>
label=Fuse Nucleus
icon=noicon
arg=<macro>
//Fuse ROI of nucleus together mainly to delete them don't use after chromocenter detection
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
if(nNuc==0){
	print("No Nucleus detected");
}
else{
	id=getImageID();
	s=nSlices();
	if(s > 1){
		run("Z Project...", "projection=["+proj+"]");
	}
	else{
		run("Select None");
		run("Duplicate...", " ");
	}
	roiManager("Show All with labels");
	//Create a name-array with all nucleus roi
	namearr=newArray(0);
	for(i=0; i<roiManager("count"); ++i){
		roiManager("Select",i); 
		rName=Roi.getName();
		if(!matches(rName,".*Chr.*")){
			namearr=appendarr(namearr, rName);
		}
	}
	Dialog.create("Select the ROI of the nucleus that need to be fused");
	for(i=0; i<namearr.length; ++i){
		Dialog.addCheckbox(namearr[i],false);
	}
	Dialog.show();
	idx=newArray(0);
	for(i=0; i<namearr.length; ++i){
		roiselect=Dialog.getCheckbox();
		if(roiselect){
			nucROI=findRoiWithName(namearr[i]);
			idx=appendarr(idx,nucROI);
		}
	}
	if(idx.length<2){
		print("Select at least 2 ROIs");
	}
	else{
		setBatchMode(true);
		roiManager("select",idx);
		roiManager("Combine");
		run("Create Mask");
		//Dilate then erode to fill 1pix space between ROIs
		run("Dilate");
		run("Erode");
		run("Create Selection");
		roiManager("add");
		roiManager("select",idx);
		roiManager("delete");
		nNuc=nNuc-idx.length+1;
		selectImage(id);
		//Rename Nucleus
		for(i=0; i<nNuc; ++i){
			roiManager("Select", i);
			idx=i+1;
			idx=nDigitsIndex(idx,3);
			roiManager("rename","Nuc_"+idx);
		}
		roiManager("Show All with labels");
		closeBut(openImg,"id");
		call("ij.Prefs.set", "variable.macro.nucleus.nNuc", nNuc);
		setBatchMode(false);
	}
}
</macro>
</line>

<line>
<button>
label=Detect Chromocenter
icon=noicon
arg=<macro>
//This will detect the chromocenters and store them in ROI manager close to the associated nucleus
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var enlarge=call("ij.Prefs.get","variable.macro.nucleus.enlarge",0);
var radchr=call("ij.Prefs.get","variable.macro.nucleus.radchr",3);
var FJsmooth=call("ij.Prefs.get", "variable.macro.nucleus.FJsmooth", 0.5);
var FJint=call("ij.Prefs.get", "variable.macro.nucleus.FJint", 3.0);
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
var bitdepth=call("ij.Prefs.get","variable.macro.nucleus.bitdepth","8-bit");
var MinChr=call("ij.Prefs.get","variable.macro.nucleus.MinChr",0.15);
var sf=call("ij.Prefs.get","variable.macro.nucleus.sf",1);
//convert MinChr to area in pixel^2
MinChr = getProjectedArea(MinChr, sf);
var MaxChr=call("ij.Prefs.get", "variable.macro.nucleus.MaxChr",0.5);
id=getImageID();
run("Grays");
run("Invert LUT");
//Create a name-array with all nucleus roi
namearr=newArray(0);
for(i=0; i<roiManager("count"); ++i){
	roiManager("Select",i); 
	rName=Roi.getName();
	if(!matches(rName,".*Chr.*")){
		namearr=appendarr(namearr, rName);
	}
}
xprev=newArray(namearr.length);
yprev=newArray(namearr.length);
for(i=0; i<namearr.length; ++i){
	run("Select None");
	Overlay.hide();
	selectImage(id);
	nucROI=findRoiWithName(namearr[i]);
	roiManager("Select", nucROI);
	nucArea=getValue("Area raw");
	nucArea=round(nucArea*MaxChr);
	run("Enlarge...", "enlarge=&enlarge pixel");
	roiManager("add");
	nROI=roiManager("count");
	roiManager("select", nROI-1);
	Roi.getBounds(xshift, yshift, width, height);
	run("Duplicate...", "duplicate");
	namedup=getTitle();
	idup=getImageID();
	run("Z Project...", "projection=["+proj+"]");
	idproj=getImageID();
	roiManager("Delete");
	selectImage(idup);
	run("FeatureJ Structure", "largest smoothing=&FJsmooth integration=&FJint");
	largest=namedup+" largest structure eigenvalues";
	selectWindow(largest);
	Stack.getStatistics(voxelCount, mean, min, max, stdDev);
	run("Divide...", "value=&max stack");
	run("Z Project...", "projection=["+proj+"]");
	run(bitdepth);
	idccfeature=getImageID();
	selectImage(idproj);
	run(bitdepth);
	run("Grays");
	run("Invert LUT");
	Dialog.createNonBlocking("Chromocenter Detection");
	Dialog.addChoice("No chromocenter, skip ?", newArray("No","Yes"));
	Dialog.show();
	nocc=Dialog.getChoice();
	if(nocc=="No"){
		selectImage(idccfeature);
		run("Interactive H_Watershed");
		waitForUser("Adjust h-watershed then export mask and clic OK");
		namedmask=getTitle();
		if(!is("binary")){
			close();
			waitForUser("Check the \"export mask\" option to export mask instead of label image and clic OK");
			namedmask=getTitle();
		}
		roiManager("Select", nucROI);
		//store nucleus ROI location
		Roi.getBounds(x, y, width, height);
		xprev[i]=x;
		yprev[i]=y;
		//Need to move the ROI when it is to close from the image upper-left corner
		Roi.move(enlarge, enlarge);
		run("Create Mask");
		imageCalculator("Multiply create", "Mask",namedmask);
		run("Analyze Particles...", "size=&MinChr-&nucArea pixel add");
		nChr=roiManager("count")-nROI;
		cpt=0;
		chridxarr=newArray(nChr+1);
		for(j=nROI-1; j<roiManager("count"); ++j){
			chridxarr[cpt]=j;
			roiManager("Select", j);
			Roi.getBounds(x, y, width, height);
			Roi.move(x+xshift, y+yshift);
			cpt=cpt+1;
			idx=nDigitsIndex(cpt,3);
			roiManager("rename",namearr[i]+"_Chr_"+idx);
		}
	}
	else{
		roiManager("Select", nucROI);
		//store nucleus ROI location
		Roi.getBounds(x, y, width, height);
		xprev[i]=x;
		yprev[i]=y;
	}
	selectImage(id);
	closeBut(openImg,"id");
	closeWindow();
	roiManager("Show All Without Labels");
	roiManager("Deselect");
}
for(i=0; i<namearr.length; ++i){
	selectImage(id);
	nucROI=findRoiWithName(namearr[i]);
	roiManager("Select", nucROI);
	Roi.move(xprev[i], yprev[i]);
}
roiManager("sort");
</macro>
</line>

<line>
<button>
label=Manualy add Chromocenter
icon=noicon
arg=<macro>
//This will allow to use the free hand drawing tool to manualy add a chromocenter
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var MinChr=call("ij.Prefs.get","variable.macro.nucleus.MinChr",0.15);
var sf=call("ij.Prefs.get","variable.macro.nucleus.sf",1);
//convert MinChr to area in pixel^2
MinChr = getProjectedArea(MinChr, sf);
var MaxChr=call("ij.Prefs.get", "variable.macro.nucleus.MaxChr",0.5);
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
if(nNuc==0){
	print("No Nucleus detected");
}
else {
	id=getImageID();
	if(nNuc==1){
		indexnuc=0;
		roiManager("select", indexnuc);
		nucName=Roi.getName();
		nucArea=getValue("Area raw");
		s=nSlices();
		if(s > 1){
			run("Z Project...", "projection=["+proj+"]");
		}
		else{
			run("Select None");
			run("Duplicate...", " ");
		}
		run("Grays");
		run("Invert LUT");
		roiManager("Show All Without Labels");
	}
	else{
		waitForUser("Select the ROI of the nucleus that contain the chromocenter, then click OK.");
		nucName=Roi.getName();
		indexnuc=findRoiWithName(nucName);
		nucArea=getValue("Area raw");
		s=nSlices();
		if(s > 1){
			run("Z Project...", "projection=["+proj+"]");
		}
		else{
			run("Select None");
			run("Duplicate...", " ");
		}
		run("Grays");
		run("Invert LUT");
		roiManager("Show All Without Labels");
	}
	//If ROI is not a nucleus
	if(matches(nucName,".*Chr.*")){
		print("Choose a nucleus ROI");
	}
	else{
		setBatchMode(true);
		nextindex=indexnuc+1;
		if(nextindex<roiManager("count")){
			roiManager("Select",nextindex);
			nextName=Roi.getName();
		}
		else{
			nextName="end";
		}
		//The chosen nucleus as no chromocenter yet
		if(!matches(nextName,".*Chr.*")){
			waitForUser("Use freehand selection to define chromocenter outline, then click OK.");
			//Trick to make the intersection with the nucleus ROI
			run("Create Mask");
			rename("1");
			roiManager("Select", indexnuc);
			run("Create Mask");
			rename("2");
			imageCalculator("Multiply", "2", "1");
			selectWindow("2");
			run("Create Selection");
			roiManager("Add");
			roiManager("select", roiManager("count")-1);
			chrArea=getValue("Area raw");
			if(chrArea<MinChr){
				roiManager("Delete");
			}
			else if (chrArea/nucArea>MaxChr){
				roiManager("Delete");
			}
			else{
				idx=nDigitsIndex(1,3);
				roiManager("rename",nucName+"_Chr_"+idx);
			}
		}
		else{
			//Count the number of chromocenter of the nucleus
			index=indexnuc+1;
			roiManager("Select",index);
			rName=Roi.getName();
			nChr=1;
			while(matches(rName,nucName+"_Chr.*")){
				index++;
				if(index<roiManager("count")){
					roiManager("Select",index);
					rName=Roi.getName();
					if(matches(rName,nucName+"_Chr.*")){
						nChr++;
					}
				}
				else{
					rName="end";
				}
			}
			waitForUser("Use freehand selection to define chromocenter outline, then click OK.");
			//Trick to make the intersection with the nucleus ROI
			run("Create Mask");
			rename("1");
			roiManager("Select", indexnuc);
			run("Create Mask");
			rename("2");
			imageCalculator("Multiply create", "1","2");
			selectWindow("Result of 1");
			run("Create Selection");
			roiManager("Add");
			roiManager("select", roiManager("count")-1);
			chrArea=getValue("Area raw");
			if(chrArea<MinChr){
				roiManager("Delete");
			}
			else if (chrArea/nucArea>MaxChr){
				roiManager("Delete");
			}
			else{
				idx=nDigitsIndex(nChr+1,3);
				roiManager("rename",nucName+"_Chr_"+idx);
			}
		}
	}
	roiManager("sort");
	setBatchMode(false);
	selectImage(id);
	roiManager("Show All with labels");
	closeBut(openImg,"id");
}
</macro>
</line>

<line>
<button>
label=Remove Chromocenter
icon=noicon
arg=<macro>
//This will allow to remove a chromocenter
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
if(nNuc==0){
	print("No Nucleus detected");
}
else{
	id=getImageID();
	s=nSlices();
	if(s > 1){
		run("Z Project...", "projection=["+proj+"]");
	}
	else{
		run("Select None");
		run("Duplicate...", " ");
	}
	roiManager("Show All with labels");
	waitForUser("Select the ROI of the unwanted chromocenter, then click OK.");
	dName=Roi.getName();
	//If ROI is a nucleus
	if(!matches(dName,".*Chr.*")){
		print("Choose a chromocenter ROI");
	}
	else{
		setBatchMode(true);
		//Find the nucleus associated with the selected chromocenter
		nucName=split(dName,"_");
		nucName=nucName[0]+"_"+nucName[1];
		indexnuc=findRoiWithName(nucName);
		nextindex=findRoiWithName(dName)+1;
		if(nextindex<roiManager("count")){
			roiManager("Select",nextindex);
			nextName=Roi.getName();
		}
		else{
			nextName="end";
		}
		delidx=findRoiWithName(dName);
		//If the selected chromocenter ROI is the only one of the nucleus
		if (delidx > 0) {
			roiManager("Select",delidx);
			roiManager("Delete");
		}
		roiManager("sort");
		setBatchMode(false);
	}
	closeBut(openImg,"id");
	selectImage(id);
	roiManager("Show All with labels");
}
</macro>
</line>

<line>
<button>
label=Show On Projection
icon=noicon
arg=<macro>
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
run("Z Project...", "projection=["+proj+"]");
run("Grays");
run("Invert LUT");
roiManager("Show All Without Labels");
</macro>
</line>

<line>
<button>
label=Save annotations
icon=noicon
arg=<macro>
//This will save the mask with background pixel = 0, nucleus = 128 and chromocenter = 255
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
var proj=call("ij.Prefs.get","variable.macro.nucleus.proj","Standard Deviation");
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
id=getImageID();
imgname=getTitle();
height=getHeight();
width=getWidth();
//Stop at the first . in image name
shortimgname=split(imgname,".");
shortimgname=shortimgname[0];
Dialog.create("Annotation");
Dialog.addString("Result file name:", shortimgname+"_label");
Dialog.show();
file=Dialog.getString();
path=getDirectory("Choose a Directory");
setBatchMode(true);
//Make a mask of all nuclei and all chromocenter
allNuc=newArray(nNuc);
for(i=0; i<nNuc; i++){
	idx=nDigitsIndex(i+1,3);
	allNuc[i]=findRoiWithName("Nuc_"+idx);
}
allCC=newArray(0);
for(i=0; i<nNuc; i++){
	if(i<nNuc-1){
		for(j=allNuc[i]+1; j<allNuc[i+1]; j++){
			allCC=appendarr(allCC, j);
		}
	}
	else{
		for(j=allNuc[i]+1; j<roiManager("count"); j++){
			allCC=appendarr(allCC, j);
		}
	}
}
//Create nuclei mask
if(allNuc.length>1){
	roiManager("Select", allNuc);
	roiManager("Combine");
}
else{
	roiManager("Select", allNuc[0]);
}
run("Create Mask");
rename("nuc");
if(allCC.length>0){
	if(allCC.length>1){
		roiManager("Select", allCC);
		roiManager("Combine");
	}
	else{
		roiManager("Select", allCC[0]);
	}
	run("Create Mask");
	rename("cc");
	//To be sure make the overlap
	imageCalculator("Multiply", "cc", "nuc");
	run("Images to Stack", "name=Stack title=[] use");
	run("Z Project...", "projection=[Sum Slices]");
}
run("8-bit");
saveAs("tiff", path+file+".tif");
print("Results have been saved to: "+path+file);
</macro>
</line>

<line>
<button>
label=Analyse Selections (2D)
icon=noicon
arg=<macro>
//This will compute nucleus and chromocenter data
var openImg=call("ij.Prefs.get", "variable.macro.nucleus.openImg", "");
openImg=split(openImg, ",");
id=getImageID();
imgname=getTitle();
var nNuc=call("ij.Prefs.get","variable.macro.nucleus.nNuc",0);
nNuc=parseInt(nNuc);
//Stop at the first . in image name
shortimgname=split(imgname,".");
shortimgname=shortimgname[0];
Dialog.create("Results");
Dialog.addString("Result file name:", shortimgname+"_result");
Dialog.addCheckbox("Delete if exit", false);
Dialog.addNumber("Decimal Places:", 9);
Dialog.show();
resfile = Dialog.getString();
resfile_nuc = resfile + "_Nuc.txt";
resfile_cc = resfile + "_CC.txt";
del=Dialog.getCheckbox();
dec=Dialog.getNumber();
DirRes=getDirectory("Choose a Directory");
param_nuc = newArray("Img", "Idx", "#CCs", "RHF", "RAF", "CCintden", "CCarea", "X", "Y", "Area", "Mean", "StdDev", "IntDen", "RawIntDen", "Round", "Circ.", "AR", "Solidity");
param_cc = newArray("Img", "Idx", "X", "Y", "Area", "Mean", "StdDev", "IntDen", "RawIntDen", "Round", "Circ.", "AR", "Solidity");
row_nuc = newArray(param_nuc.length);
row_cc = newArray(param_cc.length);
atf = 0;
if(File.exists(DirRes + resfile_nuc) && del){
	File.delete(DirRes + resfile_nuc);
	openf_nuc = File.open(DirRes + resfile_nuc);
}
else if(!File.exists(DirRes + resfile_nuc)){
	openf_nuc = File.open(DirRes + resfile_nuc);
}
else {
	atf = 1;
}
if(!atf){
	print(openf_nuc, String.join(param_nuc, ",") + "\n");
	File.close(openf_nuc);
}

atf = 0;
if(File.exists(DirRes + resfile_cc) && del){
	File.delete(DirRes + resfile_cc);
	openf_cc = File.open(DirRes + resfile_cc);
}
else if(!File.exists(DirRes + resfile_cc)){
	openf_cc = File.open(DirRes + resfile_cc);
}
else {
	atf = 1;
}
if(!atf){
	print(openf_cc, String.join(param_cc, ",") + "\n");
	File.close(openf_cc);
}
setBatchMode(true);
selectImage(id);
run("Z Project...", "projection=[Sum Slices]");
idproj=getImageID();
selectImage(idproj);
sumname = getTitle();
run("Set Measurements...", "redirect=sumname");
row_nuc[0]=imgname;
row_cc[0]=imgname;
ii=0;
i=0;
while(i<nNuc){
	//nucleus parameters
	nucidx=ii;
	roiManager("select", nucidx);
	rName=Roi.getName();
	row_nuc[1]=rName;
	for(p=7; p<param_nuc.length; ++p) {
		val=getValue(param_nuc[p]);
		row_nuc[p]=d2s(val,dec);
	}
	//chromocenter parameters
	j=nucidx+1;
	roiManager("select", j);
	rName=Roi.getName();
	while(matches(rName,".*Chr.*")&&j<roiManager("count")){
		row_cc[1]=rName;
		for(p=2; p<param_cc.length; ++p) {
			val=getValue(param_cc[p]);
			row_cc[p]=d2s(val,dec);
		}
		File.append(String.join(row_cc, "\t"), DirRes + resfile_cc);
		j=j+1;
		if(j<roiManager("count")){
			roiManager("select", j);
			rName=Roi.getName();
		}
	}
	lastccidx=j-1;
	row_nuc[2] = lastccidx-nucidx;
	if(lastccidx==nucidx){
		//no chromocenter
		row_nuc[3] = d2s(0, dec);
		row_nuc[4] = d2s(0, dec);
		row_nuc[5] = d2s(0, dec);
		row_nuc[6] = d2s(0, dec);
		File.append(String.join(row_nuc, "\t"), DirRes + resfile_nuc);
	}
	else{
		ccroi = start_end_getSequence(nucidx+1, lastccidx);
		roiManager("Select", ccroi);
		roiManager("Combine");
		roiManager("add");
		roiManager("Select", roiManager("count")-1);
		row_nuc[5] = d2s(getValue("IntDen"), dec);
		row_nuc[6] = d2s(getValue("Area"), dec);
		row_nuc[3] = d2s(row_nuc[5] / row_nuc[12], dec);
		row_nuc[4] = d2s(row_nuc[6] / row_nuc[9], dec);
		File.append(String.join(row_nuc, "\t"), DirRes + resfile_nuc);
		roiManager("delete");
	}
	i=i+1;
	ii=lastccidx+1;
}
closeBut(openImg,"id");
selectImage(id);
setBatchMode(false);
print("Results have been saved to: "+DirRes+resfile_nuc+" and "+DirRes+resfile_cc);
</macro>
</line>

<line>
<button>
label=Next Serie
icon=noicon
arg=<macro>
var sCount=call("ij.Prefs.get", "variable.macro.nucleus.sCount", 0);
sCount=parseInt(sCount)
var serie=call("ij.Prefs.get", "variable.macro.nucleus.serie", 0);
serie=parseInt(serie)
var lifs=call("ij.Prefs.get", "variable.macro.nucleus.lifs", "");
lifs=split(lifs, ",");
if(nImages()>0) {
	id=getImageID();
	selectImage(id);		
	close();
}
//Go to the next series of the current .lif file
if(serie<sCount){
	s=serie+1;
	run("Bio-Formats Importer", "open=["+lifs[0]+"] autoscale color_mode=Default view=Hyperstack stack_order=XYCZT series_"+(s));
	call("ij.Prefs.set", "variable.macro.nucleus.serie", s);
}
//Update the list of .lif files
else{
	if(lifs.length>1){
		newLifs=newArray(lifs.length-1);
		for(i=0; i<newLifs.length; ++i){
			newLifs[i]=lifs[i+1];
		}
		call("ij.Prefs.set", "variable.macro.nucleus.lifs", String.join(newLifs,","));
		run("Bio-Formats Macro Extensions");
		Ext.setId(newLifs[0]);
		Ext.getSeriesCount(seriesCount);
		sCount=seriesCount;
		call("ij.Prefs.set", "variable.macro.nucleus.sCount", sCount);
		run("Bio-Formats Importer", "open=["+newLifs[0]+"] autoscale color_mode=Default split_channels view=Hyperstack stack_order=XYCZT series_"+(1));
		call("ij.Prefs.set", "variable.macro.nucleus.serie", 1);
	}
	else{
		call("ij.Prefs.set", "variable.macro.nucleus.lifs", "");
		call("ij.Prefs.set", "variable.macro.nucleus.sCount", 0);
		call("ij.Prefs.set", "variable.macro.nucleus.serie", 0);
	}
}
if(nImages()>0) {
	//Get IDs of all opened images
	setBatchMode(true);
	ImgNamearr=newArray(nImages);
	for(i=0; i<nImages; ++i){
		selectImage(i+1);
		temp=getImageID();
		ImgNamearr[i]=temp;
	}
	call("ij.Prefs.set", "variable.macro.nucleus.openImg", String.join(ImgNamearr,","));
	run("Select None");
	run("Remove Overlay");
	setBatchMode(false);
}
else{
	call("ij.Prefs.set", "variable.macro.nucleus.openImg", "");
}
roiManager("reset");
run("Set Measurements...", "redirect=None");
call("ij.Prefs.set", "variable.macro.nucleus.nNuc", 0);
</macro>
</line>

<line>
<button>
label=Reset
icon=noicon
arg=<macro>
//Get IDs of all opened images
setBatchMode(true);
ImgNamearr=newArray(nImages);
for(i=0; i<nImages; ++i){
	selectImage(i+1);
	temp=getImageID();
	ImgNamearr[i]=temp;
}
call("ij.Prefs.set", "variable.macro.nucleus.openImg", String.join(ImgNamearr,","));
call("ij.Prefs.set","variable.macro.nucleus.nNuc",0);
setBatchMode(false);
run("Select None");
run("Remove Overlay");
roiManager("reset");
run("Set Measurements...", "redirect=None");
</macro>
</line>
